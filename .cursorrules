# Cursor Rules for EMR Project

## 프로젝트 개요
- **프레임워크**: Next.js 16.0.8 (App Router)
- **언어**: TypeScript (strict mode)
- **React**: 19.2.1
- **상태 관리**: Zustand
- **서버 상태**: TanStack Query (React Query)
- **폼 관리**: React Hook Form + Zod
- **날짜 처리**: date-fns
- **데이터베이스**: Prisma + PostgreSQL
- **API**: GraphQL (Apollo Server)

## 핵심 원칙

### 1. CSS 클래스명 관리
- **현재 방식 유지**: C007, C014, T000 같은 암호화된 클래스명 사용
- **CSS 변수 시스템**: 모든 크기와 색상은 CSS 변수 사용 (`--size-*`, `--color-*`)
- **클래스명 참조**: `docs/CSS_CLASS_REFERENCE.md` 문서를 반드시 참조하여 클래스명의 의미 파악
- **새 클래스 추가 시**: 기존 네이밍 규칙(C###, T###)을 따르고, 문서에 추가

### 2. 컴포넌트 명명 규칙
- **PascalCase 사용**: 모든 컴포넌트는 PascalCase
- **의미 있는 이름**: 기능을 명확히 나타내는 이름 사용
- **명명 규칙**: `components/NAMING_CONVENTIONS.md` 참조
- **예시**: `PageHeader`, `SlidePage`, `ScrollableContainer` (❌ `C073`, `Container` 같은 모호한 이름 금지)

### 3. 파일 구조
- **페이지**: `app/[route]/page.tsx`
- **컴포넌트**: `components/[ComponentName].tsx`
- **훅**: `hooks/use[HookName].ts`
- **타입**: `types/[category].ts`
- **스토어**: `stores/use[StoreName]Store.ts`
- **유틸리티**: `lib/utils/[utility].ts`

### 4. TypeScript 규칙
- **strict mode**: 항상 활성화
- **타입 정의**: 모든 props, 함수 파라미터, 반환값에 타입 명시
- **인터페이스**: `types/` 폴더에 정의
- **타입 가드**: `lib/type-guards.ts` 활용

### 5. React 패턴
- **함수형 컴포넌트**: 항상 함수형 컴포넌트 사용
- **"use client"**: 클라이언트 컴포넌트에 필수
- **Hooks**: 커스텀 훅은 `hooks/` 폴더에 정의
- **메모이제이션**: `React.memo`, `useMemo`, `useCallback` 적절히 사용

## 코딩 스타일

### JSX 규칙
- **className 사용**: `class` 대신 `className` 사용
- **인라인 스타일**: 객체 형태로 작성 `style={{ cursor: "pointer" }}`
- **이벤트 핸들러**: `onClick`, `onChange` 등 camelCase 사용
- **조건부 렌더링**: 삼항 연산자 또는 `&&` 사용

### 상태 관리
- **로컬 상태**: `useState` 사용
- **전역 상태**: Zustand 스토어 사용 (`stores/` 폴더)
- **서버 상태**: TanStack Query 사용
- **폼 상태**: React Hook Form 사용

### 폼 처리
- **React Hook Form**: 모든 폼은 React Hook Form 사용
- **Zod 스키마**: `lib/validations/schemas.ts`에 정의
- **검증**: `@hookform/resolvers/zod` 사용
- **커스텀 훅**: `hooks/useFormWithValidation.ts` 활용

### 날짜 처리
- **date-fns**: 모든 날짜 처리는 date-fns 사용
- **유틸리티**: `lib/utils/date.ts` 활용

## CSS 스타일링

### CSS 변수 사용
```css
/* ✅ 올바른 사용 */
width: var(--size-160);
color: var(--color-red-7);
background: var(--color-white);

/* ❌ 잘못된 사용 */
width: 160px;
color: #ff0000;
```

### 클래스명 참조
- **문서 참조**: `docs/CSS_CLASS_REFERENCE.md`에서 클래스명 의미 확인
- **레이아웃**: C007 (메인 컨테이너), C008 (페이지 헤더), C013 (사이드 패널)
- **텍스트**: T000 (사용자 이름), T001 (병원명), T003 (제목 텍스트)
- **상태 클래스**: `.isSelected`, `.isOverflowed`, `.isPending` 등

### 반응형 디자인
- **CSS 변수**: `calc()` 함수와 CSS 변수로 반응형 크기 계산
- **예시**: `width: calc(100% - var(--size-160))`

## 컴포넌트 작성 규칙

### 컴포넌트 구조
```tsx
/**
 * ComponentName Component
 *
 * @description 컴포넌트 설명
 * @component
 */
"use client";

import { useState } from "react";
import type { ComponentNameProps } from "@/types/ui";

export default function ComponentName({
  prop1,
  prop2,
}: ComponentNameProps) {
  // 상태 관리
  const [state, setState] = useState(false);

  // 이벤트 핸들러
  const handleClick = () => {
    // ...
  };

  // 렌더링
  return (
    <div className="C007">
      {/* ... */}
    </div>
  );
}
```

### Props 타입 정의
- **위치**: `types/[category].ts` 파일에 정의
- **명명**: `[ComponentName]Props` 형식
- **예시**: `PageHeaderProps`, `CustomerStatusSectionProps`

### JSDoc 주석
- **모든 컴포넌트**: JSDoc 주석으로 설명 추가
- **복잡한 로직**: 주석으로 설명 추가
- **예시**:
```tsx
/**
 * 고객 상태 섹션 컴포넌트
 * 
 * @description 원무 페이지의 고객 상태를 관리하고 표시합니다.
 * @component
 */
```

## 상태 관리 패턴

### Zustand 스토어
- **위치**: `stores/use[StoreName]Store.ts`
- **명명**: `use[StoreName]Store`
- **예시**: `useAsideStore`, `useReceptionStore`, `usePageHeaderStore`

### TanStack Query
- **쿼리 클라이언트**: `lib/query-client.tsx`에서 설정
- **캐싱**: 적절한 캐시 전략 사용
- **에러 처리**: 에러 바운더리 또는 에러 핸들링 추가

## API 및 데이터베이스

### GraphQL
- **스키마**: `graphql/schema.ts`
- **리졸버**: `graphql/resolvers.ts`
- **API 라우트**: `app/api/graphql/route.ts`

### Prisma
- **스키마**: `prisma/schema.prisma`
- **클라이언트**: `lib/prisma.ts`에서 생성
- **타입 생성**: `prisma generate` 실행

## 에러 처리

### 타입 가드
- **위치**: `lib/type-guards.ts`
- **사용**: 런타임 타입 체크

### 에러 바운더리
- **필요 시**: 에러 바운더리 컴포넌트 생성

## 성능 최적화

### 메모이제이션
- **컴포넌트**: `React.memo` 사용 (필요 시)
- **값**: `useMemo` 사용 (복잡한 계산)
- **함수**: `useCallback` 사용 (자식 컴포넌트에 전달)

### 코드 스플리팅
- **Next.js**: 자동 코드 스플리팅 활용
- **동적 import**: 필요 시 사용

## 테스트 및 검증

### 타입 체크
- **명령어**: `npm run type:check`
- **실행**: 코드 작성 후 타입 체크 실행

### 린팅
- **명령어**: `npm run lint`
- **ESLint**: Next.js 기본 설정 사용

## 문서 참조

### 필수 문서
1. **CSS 클래스 참조**: `docs/CSS_CLASS_REFERENCE.md`
2. **컴포넌트 명명 규칙**: `components/NAMING_CONVENTIONS.md`
3. **아키텍처**: `docs/ARCHITECTURE.md`
4. **타입 시스템**: `TYPESYSTEM.md`

### 문서 업데이트
- **새 클래스 추가 시**: `docs/CSS_CLASS_REFERENCE.md` 업데이트
- **새 컴포넌트 추가 시**: `components/NAMING_CONVENTIONS.md` 업데이트
- **아키텍처 변경 시**: `docs/ARCHITECTURE.md` 업데이트

## 금지 사항

### ❌ 하지 말아야 할 것들
1. **암호화된 컴포넌트명**: `C073`, `T014` 같은 이름으로 컴포넌트 생성 금지
2. **하드코딩된 값**: CSS 변수 대신 직접 값 사용 금지
3. **타입 any 사용**: 가능한 한 타입 명시
4. **class 속성**: `className` 사용
5. **문서 무시**: CSS 클래스명 사용 시 문서 참조 필수

## AI 협업 가이드

### 컨텍스트 제공
- **CSS 클래스명**: `docs/CSS_CLASS_REFERENCE.md` 참조하여 의미 파악
- **컴포넌트 구조**: 기존 컴포넌트 패턴 따르기
- **타입 정의**: `types/` 폴더의 타입 정의 확인

### 코드 생성 시
- **기존 패턴 따르기**: 기존 코드 스타일과 패턴 유지
- **타입 명시**: 모든 props, 함수에 타입 추가
- **문서 참조**: CSS 클래스명 사용 시 문서 확인

## 예시 코드

### 컴포넌트 예시
```tsx
"use client";

import { useState } from "react";
import type { ExampleProps } from "@/types/ui";

export default function Example({ title }: ExampleProps) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="C007">
      <header className="C008">
        <h1>{title}</h1>
      </header>
    </div>
  );
}
```

### 폼 예시
```tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const schema = z.object({
  name: z.string().min(1),
});

export default function FormExample() {
  const { register, handleSubmit } = useForm({
    resolver: zodResolver(schema),
  });

  return (
    <form onSubmit={handleSubmit((data) => console.log(data))}>
      <input {...register("name")} />
    </form>
  );
}
```

## 추가 참고사항

- **한국어 주석**: 프로젝트는 한국어로 작성되므로 주석도 한국어 사용
- **일관성**: 기존 코드 스타일과 일관성 유지
- **문서화**: 복잡한 로직은 주석으로 설명 추가

---

## 바이브 코딩 최적화 규칙

### 컨텍스트 자동 참조 파일
코드 생성 시 다음 파일들을 먼저 참조:
1. `@types/index.ts` - 모든 타입 중앙 export
2. `@lib/constants.ts` - 전역 상수 정의
3. `@docs/AI_CONTEXT.md` - AI 개발 컨텍스트
4. `@docs/CSS_CLASS_REFERENCE.md` - CSS 클래스 의미

### 코드 생성 우선순위
1. **기존 패턴 따르기**: 새 코드는 기존 코드 스타일과 일치해야 함
2. **타입 우선**: 코드 작성 전 타입 정의 확인
3. **상수 사용**: 하드코딩 대신 `lib/constants.ts` 상수 사용
4. **훅 재사용**: 새 훅 만들기 전 기존 훅 확인

### 자주 사용하는 패턴

#### 슬라이드 페이지 네비게이션
```typescript
import { useAsideStore } from "@/stores/useAsideStore";

// 페이지 이동
useAsideStore.getState().navigateToPage("page-id", <PageComponent />);

// 뒤로 가기
useAsideStore.getState().goBack();
```

#### PageHeader 핸들러 등록
```typescript
import { usePageHeaderStore } from "@/stores/usePageHeaderStore";

useEffect(() => {
  usePageHeaderStore.getState().setNoteClickHandler(() => {
    // 핸들러 로직
  });
}, []);
```

#### 타입 Import
```typescript
// 중앙 export에서 import (권장)
import type { PageHeaderProps, SlidePageProps } from "@/types";

// 개별 파일에서 import
import type { BaseSlideProps } from "@/types/slides";
```

### Production 빌드 호환성 필수 규칙
- ❌ `component.name` 또는 `displayName`으로 컴포넌트 감지 금지
- ✅ `pageId` 기반으로 컴포넌트 감지
- 이유: minification으로 컴포넌트 이름이 변경됨

```typescript
// ❌ 잘못된 방법
if (component.name === "MyNotesSlide") { ... }

// ✅ 올바른 방법
if (page.id.startsWith("my-notes")) { ... }
```

### 상수 파일 활용
```typescript
import {
  ROUTES,
  SLIDE_PAGE_IDS,
  ANIMATION_DURATION,
  DATE_FORMATS,
} from "@/lib/constants";

// 경로 사용
<Link href={ROUTES.reception}>원무</Link>

// 슬라이드 ID 사용
navigateToPage(SLIDE_PAGE_IDS.myNotes, <MyNotesSlide />);

// 애니메이션 시간
setTimeout(callback, ANIMATION_DURATION.normal);
```

### 디버깅 및 로깅
```typescript
// 개발 중 디버깅 (배포 전 제거)
console.log("[ComponentName] 상태:", { state });

// 조건부 로깅
if (process.env.NODE_ENV === "development") {
  console.log("Debug info:", data);
}
```

### 성능 최적화 패턴
```typescript
// 메모이제이션
const memoizedValue = useMemo(() => expensiveCalculation(), [deps]);
const memoizedCallback = useCallback(() => handler(), [deps]);

// 컴포넌트 메모
export default memo(ComponentName);

// 이전 값 비교로 불필요한 실행 방지
const prevRef = useRef<string | null>(null);
useEffect(() => {
  if (prevRef.current === currentValue) return;
  prevRef.current = currentValue;
  // 로직 실행
}, [currentValue]);
```

---

## 파일 생성 체크리스트

### 새 컴포넌트 생성 시
- [ ] `types/` 폴더에 Props 인터페이스 정의
- [ ] `types/index.ts`에 export 추가
- [ ] JSDoc 주석 작성 (한국어)
- [ ] 기존 패턴 따르기 (imports, 구조, 스타일)

### 새 페이지 생성 시
- [ ] `app/[page]/page.tsx` 생성
- [ ] PageHeader 핸들러 설정
- [ ] Aside mainContent 설정
- [ ] Sidebar 메뉴 확인

### 새 슬라이드 생성 시
- [ ] `components/slides/[Name].tsx` 생성
- [ ] `types/slides.ts`에 Props 추가
- [ ] `PRE_WRAPPED_SLIDE_PAGE_IDS`에 ID 추가 (필요시)

### 새 팝업 생성 시
- [ ] `components/popups/[Name].tsx` 생성
- [ ] `types/popups.ts`에 Props 추가
- [ ] `BasePopupProps` 확장
